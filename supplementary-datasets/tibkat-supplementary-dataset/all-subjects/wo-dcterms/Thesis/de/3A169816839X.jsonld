{
    "@graph": [
        {
            "@id": "gnd:1209551411",
            "sameAs": "Nutz, Alexander"
        },
        {
            "@id": "gnd:4055382-6",
            "sameAs": "Software"
        },
        {
            "@id": "gnd:4076370-5",
            "sameAs": "Programmierung"
        },
        {
            "@id": "gnd:4135577-5",
            "sameAs": "Verifikation"
        },
        {
            "@id": "gnd:4506115-4",
            "sameAs": "Formaler Beweis"
        },
        {
            "@id": "https://www.tib.eu/de/suchen/id/TIBKAT%3A169816839X",
            "@type": "bibo:Thesis",
            "P1053": "1 Online-Ressource (vii, 105 Seiten)",
            "identifier": [
                "(ppn)169816839X",
                "(contract)FRUB-opus-165473",
                "(firstid)KXP:169816839X",
                "(doi)10.6094/UNIFR/165473"
            ],
            "http://purl.org/dc/elements/1.1/subject": [
                "(classificationName=linseach:mapping)inf",
                "(classificationName=ddc)005.14",
                "(classificationName=ddc-dbn)004"
            ],
            "title": "Data flow in program verification",
            "abstract": [
                "Abstract: Gegenstand dieser Arbeit ist die theoretische und praktische Untersuchung von  Techniken, die die Verfikation von Programmen unterst\u00fctzen sollen. Den vorge-  stellten Techniken gemeinsam ist, dass ihnen das Konzept des Datenflusses zu-  grundeliegt. Zwischen Programmbefehl s und Programmbefehl s' besteht ein Da-  tenfluss, wenn s einen Wert in den Speicher schreibt, den s' verwendet (also aus  dem Speicher liest). Dieses Konzept legt eine bestimmte Sicht auf das zu verifizie-  rende Programm nahe. Wenn man zum Beispiel herausfinden will, welche Werte  eine bestimmte Variable in einem bestimmten Programmbefehl annehmen kann,  dann scheint es nat\u00fcrlich, alle eingehenden Datenfl\u00fcsse zur\u00fcckzuverfolgen, um her-  auszufinden, mit welchen Werte die Variable geschrieben worden sein kann. Diese  Werte k\u00f6nnen ihrerseits wiederum von anderen Variablen abh\u00e4ngen, sodass weite-  re Datenfl\u00fcsse zur\u00fcckverfolgt werden m\u00fcssen, bis alle m\u00f6glichen Werte ermittelt  werden k\u00f6nnen.  Es gibt ein breites Spektrum von M\u00f6glichkeiten, diese Sicht auf Programme  zu deren Verifikation einzusetzen. Die folgenden drei Fragen bilden einen Auszug  aus diesem Spektrum: 1. Ein Analogon zu klassischen Floyd-Beweisen sind Daten-  flussbeweise. Was sind die Vor- und Nachteile von Datenflussbeweisen? 2. Durch  die Anwesenheit von Arrays im Programm wird es deutlich schwieriger, eine gu-  te Charakterisierung der im Programm m\u00f6glichen Datenfl\u00fcsse zu ermitteln. Gibt  es eine abstrakte Dom\u00e4ne (im Sinne der abstrakten Interpretation von Program-  men), die gut skaliert und m\u00e4chtig genug ist, um eine n\u00fctzliche Approximation  der Datenfl\u00fcsse in einem Programm mit Arrays herzuleiten? 3. Die Abwesenheit  von bestimmten Datenfl\u00fcssen in einem gegebenen Programm mit Arrays (und die  daraus resultierende Unabh\u00e4ngigkeit der zugeh\u00f6rigen Programmbefehle) ist h\u00e4ufig  ein wichtiger und schwer zu inferierender Bestandteil des Korrektheitsbeweises des  Programms. Ist es m\u00f6glich eine Programmtransformation zu entwerfen, die diese  Information (\u00fcber die Abwesenheit von Datenfl\u00fcssen) in das transformierte Pro-  gramm enkodiert, sodass die anschlie\u00dfende Verifikation des Programms diese Be-  weisaufgaben nicht mehr zu erledigen braucht? Diese drei Fragen sollen in dieser  Arbeit beantwortet werden",
                "Abstract: We present several techniques and insights that aid program verification. The common theme of these techniques and insights is their relation to the notion of data flow. Intuitively, there is a data flow from program statement s to program statement s' if s writes a value (to memory) that s' uses (reads from memory). This notion induces a particular view on a program that is to be verified. For example, when we want to find out which values a certain variable in a certain statement can assume in a program, it is natural to check all the incoming data flows for that variable in that statement and see which values they provide. Of course, the provided values may depend on other data flows and so on. There is a wide variety of ways to apply this view on programs in program verification. For this thesis, we picked the following three questions. 1. The analogue to classical Floyd proofs in the data flow view are data flow proofs. What is their potential and what are their limitations? 2. Data flow becomes much more complex in the presence of arrays. Can we develop a scalable abstract domain that is powerful enough to find a good approximation of the data flow relationships in a program with arrays? 3. The absence of data flows in a program with arrays (i.e., the independence of certain statements) is often an essential and difficult part of the program\u2019s correctness proof. Can we give a program transformation that encodes this information into the transformed program in order to relieve some backend-verifier of these proof tasks? In this thesis we will give answers to these three questions"
            ],
            "contributor": "Technische Informationsbibliothek (TIB)",
            "creator": "gnd:1209551411",
            "isPartOf": "(collectioncode)GBV-ODiss",
            "issued": "2019",
            "language": "http://id.loc.gov/vocabulary/iso639-1/en",
            "license": "open access",
            "medium": "rda:termList/RDACarrierType/1018",
            "subject": [
                "gnd:4076370-5",
                "gnd:4506115-4",
                "gnd:4055382-6",
                "gnd:4135577-5"
            ],
            "isLike": "doi:10.6094/UNIFR/165473",
            "P60163": "Freiburg"
        }
    ],
    "@id": "urn:x-arq:DefaultGraphNode",
    "@context": {
        "creator": {
            "@id": "http://purl.org/dc/terms/creator",
            "@type": "@id"
        },
        "language": {
            "@id": "http://purl.org/dc/terms/language",
            "@type": "@id"
        },
        "identifier": "http://purl.org/dc/elements/1.1/identifier",
        "issued": "http://purl.org/dc/terms/issued",
        "subject": {
            "@id": "http://purl.org/dc/terms/subject",
            "@type": "@id"
        },
        "P1053": "http://iflastandards.info/ns/isbd/elements/P1053",
        "P60163": "http://www.rdaregistry.info/Elements/u/#P60163",
        "title": "http://purl.org/dc/elements/1.1/title",
        "medium": {
            "@id": "http://purl.org/dc/terms/medium",
            "@type": "@id"
        },
        "contributor": "http://purl.org/dc/terms/contributor",
        "isLike": {
            "@id": "http://umbel.org/umbel#isLike",
            "@type": "@id"
        },
        "abstract": "http://purl.org/dc/terms/abstract",
        "isPartOf": "http://purl.org/dc/terms/isPartOf",
        "license": "http://purl.org/dc/terms/license",
        "sameAs": "http://www.w3.org/2002/07/owl#sameAs",
        "umbel": "http://umbel.org/umbel#",
        "rdau": "http://www.rdaregistry.info/Elements/u/#",
        "owl": "http://www.w3.org/2002/07/owl#",
        "dcterms": "http://purl.org/dc/terms/",
        "bibo": "http://purl.org/ontology/bibo/",
        "rdam": "http://www.rdaregistry.info/Elements/m/#",
        "gnd": "http://d-nb.info/gnd/",
        "isbd": "http://iflastandards.info/ns/isbd/elements/",
        "rda": "http://rdvocab.info/",
        "doi": "https://doi.org/"
    }
}