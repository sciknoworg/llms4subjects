{
    "@graph": [
        {
            "@id": "gnd:1335090525",
            "sameAs": "Schuster, Philipp"
        },
        {
            "@id": "gnd:36187-2",
            "sameAs": "Eberhard Karls Universit\u00e4t T\u00fcbingen"
        },
        {
            "@id": "https://www.tib.eu/de/suchen/id/TIBKAT%3A1891280295",
            "@type": "bibo:Thesis",
            "P1053": "1 Online-Ressource (vii, 110 Seiten)",
            "identifier": [
                "(firstid)KXP:1891280295",
                "(doi)10.15496/publikation-95440",
                "(ppn)1891280295"
            ],
            "subject": [
                "(classificationName=linseach:mapping)inf",
                "Programmierung",
                "(classificationName=ddc-dbn)005.1",
                "(classificationName=ddc-dbn)004",
                "Nat\u00fcrliche Semantik"
            ],
            "title": "Compiling lexical effect handlers with capabilities, continuations, and evidence",
            "abstract": [
                "The ever increasing demand for software in an ever increasing number of different domains leads to an ever increasing complexity of programs. To scale the size and complexity of software, programmers compose programs out of individual, reusable parts. These parts are discovered to be commonly useful and shared as libraries. To enable this sharing and reuse, programming languages must offer a way to abstract over patterns of code and to concretize the pattern to specific use cases. Moreover, as the scale of software increases, it becomes more and more important that programmers are able to ascertain themselves of the correctness of one part of the program without looking at all the other parts. Effects are a class of language features that makes programs interact with their context in a non-trivial way. Examples are file system access, mutable state, exceptions, generators, and more. Most languages include some of these features in one form or another, which speaks to their usefulness. However, it is widely agreed upon that undisciplined use of effects leads to programs that are hard to get correct, hard to understand, and hard to maintain. Moreover, each of these individual features must be built into a programming language and while doing so their combination must be carefully considered. Finally, programmers cannot abstract over these features and therefore not share them nor extend them in ways unforeseen by the programming language implementor. Effect handlers are a relatively recent programming language feature that subsumes many existing language features for effects, and even goes beyond what most programming languages offer. With effect handlers, effects like mutable state, exceptions, or generators are user-defined. This allows for abstraction over repeated patterns involving different kinds of effects. Naturally, programmers can share and reuse these abstractions in different contexts and even invent their own effects which opens up a whole new design space. Moreover, effect handlers delimit the extent of effects, which gives programmers certain guarantees without inspecting the entire program. In other words, they enforce a disciplined use of effects. In this thesis we present a compilation technique for effect handlers, which will help this programming language feature to move from theory to practice. Compiled programs do not need any runtime support, which makes it widely deployable. It enables aggressive compile-time optimizations, which makes it efficient. It supports programs using more exotic effects like non-determinism, which makes it general. It is also of theoretical interest, because it targets well-known and well-studied languages. In summary, our compilation technique enables new kinds of abstractions without regret for programs using effect handlers.",
                "Der st\u00e4ndig steigende Bedarf an Software in immer unterschiedlicheren Bereichen f\u00fchrt zu einer immer gr\u00f6\u00dferen Komplexit\u00e4t der Programme. Um die Gr\u00f6\u00dfe und Komplexit\u00e4t von Software zu skalieren, setzen Programmierer die Programme aus einzelnen, wiederverwendbaren Teilen zusammen. Diese Teile werden als allgemein n\u00fctzlich erkannt und als Software-Bibliotheken geteilt. Um diese gemeinsame Nutzung und Wiederverwendung zu erm\u00f6glichen, m\u00fcssen Programmiersprachen M\u00f6glichkeiten bieten, \u00fcber Code-Muster zu abstrahieren und diese sp\u00e4ter wieder zu konkretisieren. Au\u00dferdem wird es mit zunehmendem Umfang der Software immer wichtiger, dass die Programmierer in der Lage sind, sich von der Korrektheit eines Teils des Programms zu \u00fcberzeugen, ohne sich alle anderen Teile anzuschauen. Effekte sind eine Klasse von Sprachkonstrukten, die Programme auf nicht-triviale Weise mit ihrem Kontext interagieren l\u00e4sst. Beispiele sind der Zugriff auf das Dateisystem, ver\u00e4nderliche Referenzen, Ausnahmen, Generatoren und mehr. Die meisten Sprachen enthalten eine Auswahl dieser Konstrukte in unterschiedlichen Variationen, was f\u00fcr ihre N\u00fctzlichkeit spricht. Es besteht jedoch weitgehend Einigkeit dar\u00fcber, dass undisziplinierte Verwendung von Effekten zu Programmen f\u00fchrt, die schwer korrekt zu erstellen, schwer zu verstehen und schwer zu pflegen sind. Des Weiteren muss jedes einzelne dieser Konstrukte in jede einzelne Programmiersprache eingebaut werden, und dabei muss ihre Kombination sorgf\u00e4ltig bedacht werden. Schlie\u00dflich k\u00f6nnen Programmierer nicht \u00fcber diese Konstrukte selbst abstrahieren und sie daher nicht gemeinsam nutzen oder in einer Weise erweitern, die der Implementierer der Programmiersprache nicht vorhergesehen hat. Effekt-Handler sind ein relativ neues Sprachkonstrukt, das viele bestehende Konstrukte f\u00fcr Effekte ausdr\u00fccken kann und sogar \u00fcber das hinausgeht, was die meisten Programmiersprachen anbieten. Mit Effekt-Handlern k\u00f6nnen Effekte wie ver\u00e4nderliche Referenzen, Ausnahmen oder Generatoren von Benutzern der Programmiersprache definiert werden. Dies erm\u00f6glicht die Abstraktion \u00fcber wiederholte Muster, die Effekte verwenden. Nat\u00fcrlich k\u00f6nnen die Programmierer diese Abstraktionen in verschiedenen Kontexten gemeinsam nutzen und wiederverwenden und sogar ihre eigenen Effekte erfinden, was ganz neue Gestaltungsm\u00f6glichkeiten er\u00f6ffnet. Dar\u00fcber hinaus grenzen Effekt-Handler den Kontext von Effekten ab, was dem Programmierer gewisse Garantien gibt, ohne dass er das gesamte Programm inspizieren muss. Mit anderen Worten, sie erzwingen einen disziplinierten Gebrauch von Effekten. In dieser Thesis stellen wir eine Kompilierungstechnik f\u00fcr Effekt-Handler vor, welche dabei hilft, dieses Sprachkonstrukt von der Theorie in die Praxis zu bringen. Kompilierte Programme ben\u00f6tigen keine Laufzeitunterst\u00fctzung, was sie weithin einsetzbar macht. Sie erm\u00f6glicht aggressive Optimierungen zur Kompilierzeit, was sie effizient macht. Sie unterst\u00fctzt Programme, die exotischere Effekte wie Nicht-Determinismus verwenden, was sie allgemein einsetzbar macht. Sie ist auch von theoretischem Interesse, da sie in bekannte und gut untersuchte Programmiersprachen \u00fcbersetzt. Zusammenfassend: Unsere Kompilierungstechnik erm\u00f6glicht neue Arten von Abstraktion ohne Bedauern in Programmen, die Effekt-Handler verwenden."
            ],
            "contributor": "Technische Informationsbibliothek (TIB)",
            "creator": [
                "gnd:1335090525",
                "gnd:36187-2"
            ],
            "isPartOf": "(collectioncode)GBV-ODiss",
            "issued": "2022",
            "language": "http://id.loc.gov/vocabulary/iso639-1/en",
            "license": "open access",
            "medium": "rda:termList/RDACarrierType/1018",
            "isLike": "doi:10.15496/publikation-95440",
            "P60163": "T\u00fcbingen"
        }
    ],
    "@id": "urn:x-arq:DefaultGraphNode",
    "@context": {
        "identifier": "http://purl.org/dc/elements/1.1/identifier",
        "license": "http://purl.org/dc/terms/license",
        "creator": {
            "@id": "http://purl.org/dc/terms/creator",
            "@type": "@id"
        },
        "isLike": {
            "@id": "http://umbel.org/umbel#isLike",
            "@type": "@id"
        },
        "subject": "http://purl.org/dc/elements/1.1/subject",
        "isPartOf": "http://purl.org/dc/terms/isPartOf",
        "issued": "http://purl.org/dc/terms/issued",
        "P1053": "http://iflastandards.info/ns/isbd/elements/P1053",
        "abstract": "http://purl.org/dc/terms/abstract",
        "medium": {
            "@id": "http://purl.org/dc/terms/medium",
            "@type": "@id"
        },
        "contributor": "http://purl.org/dc/terms/contributor",
        "language": {
            "@id": "http://purl.org/dc/terms/language",
            "@type": "@id"
        },
        "title": "http://purl.org/dc/elements/1.1/title",
        "P60163": "http://www.rdaregistry.info/Elements/u/#P60163",
        "sameAs": "http://www.w3.org/2002/07/owl#sameAs",
        "umbel": "http://umbel.org/umbel#",
        "rdau": "http://www.rdaregistry.info/Elements/u/#",
        "owl": "http://www.w3.org/2002/07/owl#",
        "dcterms": "http://purl.org/dc/terms/",
        "bibo": "http://purl.org/ontology/bibo/",
        "rdam": "http://www.rdaregistry.info/Elements/m/#",
        "gnd": "http://d-nb.info/gnd/",
        "isbd": "http://iflastandards.info/ns/isbd/elements/",
        "rda": "http://rdvocab.info/",
        "doi": "https://doi.org/"
    }
}